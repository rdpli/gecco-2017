#include <iostream>
#include "VX_Object.h"
#include "VX_Environment.h"
#include "VX_Sim.h"
#include "VX_SimGA.h"
#include "VX_MeshUtil.h"
#include "VXS_SimGLView.h"

int main(int argc, char *argv[])
{
	char* InputFile;
	//create the main objects
	CVXC_Structure structure;
	CVX_Object Object;
	CVX_Environment Environment;
	CVX_SimGA Simulator;
	CVX_MeshUtil VoxMesh;

	long int Step = 0;
	vfloat Time = 0.0; //in seconds
	bool print_scrn = false;

	// TODO: add --genVolumeInfo option?
	//first, parse inputs. Use as: -f followed by the filename of the .vxa file that describes the simulation. Can also follow this with -p to cause console output to occur
	if (argc < 3) 
	{ // Check the value of argc. If not enough parameters have been passed, inform user and exit.
		std::cout << "\nInput file required. Quitting.\n";
		return(0);	//return, indicating via code (0) that we did not complete the simulation
	} 
	else 
	{ // if we got enough parameters...
		for (int i = 1; i < argc; i++) 
		{ 
			if (strcmp(argv[i],"-f") == 0) 
			{
				InputFile = argv[i + 1];	// We know the next argument *should* be the filename:
			} 
			else if (strcmp(argv[i],"-p") == 0) 
			{
				print_scrn=true;	//decide if output to the console is desired
			}
		}
	} 

	//setup main object
	Simulator.pEnv = &Environment;	//connect Simulation to environment
	Environment.pObj = &Object;		//connect environment to object

	//import the configuration file
	if (!Simulator.LoadVXAFile(InputFile)){
		if (print_scrn) std::cout << "\nProblem importing VXA file. Quitting\n";
		return(0);	//return, indicating via code (0) that we did not complete the simulation
		}
	std::string ReturnMessage;
	if (print_scrn) std::cout << "\nImporting Environment into simulator...\n";

	Simulator.Import(&Environment, 0, &ReturnMessage);
	if (print_scrn) std::cout << "Simulation import return message:\n" << ReturnMessage << "\n";
	
	Simulator.pEnv->UpdateCurTemp(Time);	//set the starting temperature (nac: pointer removed for debugging)

	// create a deformable mesh and link it to the physics simulation
	VoxMesh.LinkSimVoxels(&Simulator, NULL);
	VoxMesh.DefMesh.DrawSmooth=false; // don't use marching cubes

	double hulVolumeStart, hulVolumeEnd, robotVolumeStart, robotVolumeEnd;

	hulVolumeStart = Simulator.computeAndStoreQHullStart();
	robotVolumeStart = Simulator.computeAndStoreRobotVolumeStart();

	if (print_scrn)
		std::cout << "Init robot volume: " << robotVolumeStart << std::endl 
				  << "Init convex hull volume: " << hulVolumeStart << std::endl;

	// Generate mesh for the initial state

    VoxMesh.UpdateMesh(-1);
    //VoxMesh.DefMesh.SaveSTL("initial.stl", true, true);
	if(print_scrn)
		std::cout << "Initial mesh has " << VoxMesh.DefMesh.Vertices.size() << " vertices and " << VoxMesh.DefMesh.Facets.size() << " facets" << std::endl;
	

// -------------------------------------------------------------------------------

		std::cout << "VERTICES INIT" << std::endl;

		std::vector<CVertex>::iterator VIt;
		for(VIt=VoxMesh.DefMesh.Vertices.begin(); VIt != VoxMesh.DefMesh.Vertices.end(); VIt++)
		{
			std::cout << VIt->v.x + VIt->DrawOffset.x << "\t" << VIt->v.y + VIt->DrawOffset.y << "\t" << VIt->v.z + VIt->DrawOffset.z << std::endl;

/*			if (VIt->n != Vec3D<>(0,0,0))
			{
				std::cout << "Nx " << VIt->n.x << std::endl;
				std::cout << "Ny " << VIt->n.y << std::endl;
				std::cout << "Nz " << VIt->n.z << std::endl;
			}else
				std::cout << "NO NORMALS FOR THIS VERTEX" << std::endl;
*/	
		}
		
		std::cout << "FACETS INIT" << std::endl;

		std::vector<CFacet>::iterator FIt;
		for(FIt=VoxMesh.DefMesh.Facets.begin(); FIt != VoxMesh.DefMesh.Facets.end(); FIt++)
		{

			std::cout << FIt->vi[0] << "\t" << FIt->vi[1] << "\t" << FIt->vi[2] << std::endl;

/*			if (FIt->n != Vec3D<>(0,0,0)){
				std::cout << "Nx " << FIt->n.x << std::endl;
				std::cout << "Ny " << FIt->n.y << std::endl;
				std::cout << "Nz " << FIt->n.z << std::endl;

			}else
				std::cout << "NO NORMALS FOR THIS FACET" << std::endl;			
*/
		}	
		
// -------------------------------------------------------------------------------
	

	while (not Simulator.StopConditionMet())
	{
		// do some reporting via the stdoutput if required:
		if (Step%100 == 0.0 && print_scrn) //Only output every n time steps
		{
			std::cout << "Time: " << Time << std::endl;
			std::cout << "CM: " << Simulator.GetCM().Length() << std::endl << std::endl;
			
			// std::cout << " \tVox 0 X: " << Vox0Pos.x << "mm" << "\tVox 0 Y: " << Vox0Pos.y << "mm" << "\tVox 0 Z: " << Vox0Pos.z << "mm\n";	//just display the position of the first voxel in the voxelarray
			std::cout << "Vox[0]  Scale: " << Simulator.VoxArray[0].GetCurScale() << std::endl;
			std::cout << "Vox[0]  TempAmp: " << Simulator.VoxArray[0].TempAmplitude << std::endl;
			std::cout << "Vox[0]  TempPer: " << Simulator.VoxArray[0].TempPeriod << std::endl;
			std::cout << "Vox[0]  phaseOffset: " << Simulator.VoxArray[0].phaseOffset << std::endl;
			// std::cout << "Vox[5]  Scale: " << Simulator.VoxArray[5].GetCurScale() << std::endl;
			// std::cout << "Vox[10] Scale: " << Simulator.VoxArray[10].GetCurScale() << std::endl;
		}

		//do the actual simulation step
		Simulator.TimeStep(&ReturnMessage);
		Step += 1;	//increment the step counter
		Time += Simulator.dt;	//update the sim tim after the step
		Simulator.pEnv->UpdateCurTemp(Time);	//pass in the global time, and a pointer to the local object so its material temps can be modified (nac: pointer removed for debugging)	
	}

	// Generate mesh for the final state
	VoxMesh.UpdateMesh(-1);
	if(print_scrn)
		std::cout << "Final mesh has " << VoxMesh.DefMesh.Vertices.size() << " vertices and " << VoxMesh.DefMesh.Facets.size() << " facets" << std::endl;

    //VoxMesh.DefMesh.SaveSTL("final.stl", true, true);

	hulVolumeEnd = Simulator.computeAndStoreQHullEnd();
	robotVolumeEnd = Simulator.computeAndStoreRobotVolumeEnd();

	if (print_scrn)
		std::cout << "Final robot volume: " << robotVolumeEnd << std::endl 
				  << "Final convex hull volume: " << hulVolumeEnd << std::endl;

	if (print_scrn) std::cout << "Ended at: " << Time << std::endl;

// -------------------------------------------------------------------------------

		std::cout << "VERTICES FINAL" << std::endl;

		for(VIt=VoxMesh.DefMesh.Vertices.begin(); VIt != VoxMesh.DefMesh.Vertices.end(); VIt++)
		{
			std::cout << VIt->v.x + VIt->DrawOffset.x << "\t" << VIt->v.y + VIt->DrawOffset.y << "\t" << VIt->v.z + VIt->DrawOffset.z << std::endl;

/*			if (VIt->n != Vec3D<>(0,0,0))
			{
				std::cout << "Nx " << VIt->n.x << std::endl;
				std::cout << "Ny " << VIt->n.y << std::endl;
				std::cout << "Nz " << VIt->n.z << std::endl;
			}else
				std::cout << "NO NORMALS FOR THIS VERTEX" << std::endl;
*/	
		}
		
		std::cout << "FACETS FINAL" << std::endl;

		for(FIt=VoxMesh.DefMesh.Facets.begin(); FIt != VoxMesh.DefMesh.Facets.end(); FIt++)
		{

			std::cout << FIt->vi[0] << "\t" << FIt->vi[1] << "\t" << FIt->vi[2] << std::endl;

/*			if (FIt->n != Vec3D<>(0,0,0)){
				std::cout << "Nx " << FIt->n.x << std::endl;
				std::cout << "Ny " << FIt->n.y << std::endl;
				std::cout << "Nz " << FIt->n.z << std::endl;

			}else
				std::cout << "NO NORMALS FOR THIS FACET" << std::endl;			
*/
		}	
		
// -------------------------------------------------------------------------------
	
	Simulator.SaveResultFile(Simulator.FitnessFileName);

	return 1;	//code for successful completion  // could return fitness value if greater efficiency is desired
}
